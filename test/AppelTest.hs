{-
    Copyright (C) 2017, Garret Wassermann.

    This file is part of tigerc, the Tiger language compiler,
    based on the Tiger language in "Modern Compiler Implementation
    in ML" by Andrew W. Appel.

    tigerc is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    tigerc is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with tigerc.  If not, see <http://www.gnu.org/licenses/>.
-}

module AppelTest where

import Test.Tasty (defaultMain, testGroup, TestTree)
import Test.Tasty.HUnit (assertEqual, testCase)

import Tiger.Lexical.Lexer (alexMonadScanTokens)
import Tiger.Lexical.Tokens (Token(..))
import Tiger.Syntactic.Parser (happyTokenParse)
import Tiger.Syntactic.AST (Program(..), Exp(..), Var(..), Decl(..), Type(..), Op(..), Symbol, Field(..), FunDecl(..))
                             
-- these tests are based on the ones written by Appel in sample ML code,
-- and distributed via the textbook website
appelTests = testGroup "Appel's original tests for Tiger" [testParseAppel1, testParseAppel2, testParseAppel3, testParseAppel4, testParseAppel5, testParseAppel6, testParseAppel7, testParseAppel8, testParseAppel9, testParseAppel10, testParseAppel11, testParseAppel12, testParseAppel13, testParseAppel14, testLexAppel15, testParseAppel15, testParseAppel16, testParseAppel17, testParseAppel18, testParseAppel19, testParseAppel20, testParseAppel21, testParseAppel22, testParseAppel23, testParseAppel24, testParseAppel25, testParseAppel26, testParseAppel27, testParseAppel28, testParseAppel29, testParseAppel30, testParseAppel31, testParseAppel32, testParseAppel33,testParseAppel34, testParseAppel35, testParseAppel36, testParseAppel37, testParseAppel38, testParseAppel39, testParseAppel40, testParseAppel41, testParseAppel42, testParseAppel43, testParseAppel44, testParseAppel45, testParseAppel46, testParseAppel47, testParseAppel48, testLexAppel49, testParseAppelMerge, testParseAppelQueens]

-- TODO: maybe use testCaseSteps in future when do typechecking?
-- (https://hackage.haskell.org/package/tasty-hunit-0.9.2/docs/Test-Tasty-HUnit.html)

testParseAppel1 =
    testCase "parses test1 (read from file)" $ (readFile "test/appeltestcases/test1.tig" >>= (assertEqual [] (Program $ LetExp [TypeDecl "arrtype" (ArrayType "int"), VarDecl "arr1" True (Just "arrtype") (ArrayExp "arrtype" (IntExp 10) (IntExp 0))] (VarExp $ SimpleVar "arr1"))) . happyTokenParse . alexMonadScanTokens)
testParseAppel2 =
    testCase "parses test2 (read from file)" $ (readFile "test/appeltestcases/test2.tig" >>= (assertEqual [] (Program $ LetExp [TypeDecl "myint" (NameType "int"), TypeDecl "arrtype" (ArrayType "myint"), VarDecl "arr1" True (Just "arrtype") (ArrayExp "arrtype" (IntExp 10) (IntExp 0))] (VarExp $ SimpleVar "arr1"))) . happyTokenParse . alexMonadScanTokens)
testParseAppel3 =
    testCase "parses test3 (read from file)" $ (readFile "test/appeltestcases/test3.tig" >>= (assertEqual [] (Program $ LetExp [TypeDecl "rectype" (RecordType [Field "name" True "string", Field "age" True "int"]), VarDecl "rec1" True (Just "rectype") (RecordExp [("age", IntExp 1000), ("name", StrExp "Nobody")] ("rectype"))] (SeqExp [AssignExp (FieldVar (SimpleVar "rec1") "name") (StrExp "Somebody"), VarExp $ SimpleVar "rec1"]))) . happyTokenParse . alexMonadScanTokens)
testParseAppel4 =
    testCase "parses test4 (read from file)" $ (readFile "test/appeltestcases/test4.tig" >>= (assertEqual [] (Program (LetExp {decls = [FunDecls [FunDecl {fundeclname = "nfactor", params = [Field {fieldname = "n", escape = True, typ = "int"}], result = Just "int", body = IfExp {iftest = OpExp {left = VarExp (SimpleVar "n"), oper = Equal, right = IntExp 0}, thenexp = IntExp 1, elseexp = Just (OpExp {left = VarExp (SimpleVar "n"), oper = Mul, right = CallExp {func = "nfactor", args = [OpExp {left = VarExp (SimpleVar "n"), oper = Sub, right = IntExp 1}]}})}}]], lbody = CallExp {func = "nfactor", args = [IntExp 10]}}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel5 =
    testCase "parses test5 (read from file)" $ (readFile "test/appeltestcases/test5.tig" >>= (assertEqual [] (Program (LetExp {decls = [TypeDecl {tname = "intlist", ttyp = RecordType [Field {fieldname = "hd", escape = True, typ = "int"},Field {fieldname = "tl", escape = True, typ = "intlist"}]}, TypeDecl {tname = "tree", ttyp = RecordType [Field {fieldname = "key", escape = True, typ = "int"},Field {fieldname = "children", escape = True, typ = "treelist"}]},TypeDecl {tname = "treelist", ttyp = RecordType [Field {fieldname = "hd", escape = True, typ = "tree"},Field {fieldname = "tl", escape = True, typ = "treelist"}]},VarDecl {vname = "lis", vescape = True, vtyp = Just "intlist", vinit = RecordExp {fields = [("tl",NilExp),("hd",IntExp 0)], rtyp = "intlist"}}], lbody = VarExp (SimpleVar "lis")}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel6 =
    testCase "parses test6 (read from file)" $ (readFile "test/appeltestcases/test6.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [FunDecls [FunDecl {fundeclname = "do_nothing1", params = [Field {fieldname = "a", escape = True, typ = "int"},Field {fieldname = "b", escape = True, typ = "string"}], result = Nothing, body = CallExp {func = "do_nothing2", args = [OpExp {left = VarExp (SimpleVar "a"), oper = Add, right = IntExp 1}]}},FunDecl {fundeclname = "do_nothing2", params = [Field {fieldname = "d", escape = True, typ = "int"}], result = Nothing, body = CallExp {func = "do_nothing1", args = [VarExp (SimpleVar "d"),StrExp "str"]}}]], lbody = CallExp {func = "do_nothing1", args = [IntExp 0,StrExp "str2"]}}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel7 =
    testCase "parses test7 (read from file)" $ (readFile "test/appeltestcases/test7.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [FunDecls [FunDecl {fundeclname = "do_nothing1", params = [Field {fieldname = "a", escape = True, typ = "int"},Field {fieldname = "b", escape = True, typ = "string"}], result = Just "int", body = SeqExp [CallExp {func = "do_nothing2", args = [OpExp {left = VarExp (SimpleVar "a"), oper = Add, right = IntExp 1}]},IntExp 0]},FunDecl {fundeclname = "do_nothing2", params = [Field {fieldname = "d", escape = True, typ = "int"}], result = Just "string", body = SeqExp [CallExp {func = "do_nothing1", args = [VarExp (SimpleVar "d"),StrExp "str"]},StrExp " "]}]], lbody = CallExp {func = "do_nothing1", args = [IntExp 0,StrExp "str2"]}}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel8 =
    testCase "parses test8 (read from file)" $ (readFile "test/appeltestcases/test8.tig" >>= (assertEqual [] (Program $ IfExp {iftest = OpExp {left = IntExp 10, oper = GreaterThan, right = IntExp 20}, thenexp = IntExp 30, elseexp = Just $ IntExp 40})) . happyTokenParse . alexMonadScanTokens)
testParseAppel9 =
    testCase "parses test9 (read from file)" $ (readFile "test/appeltestcases/test9.tig" >>= (assertEqual [] (Program $ IfExp {iftest = OpExp {left = IntExp 5, oper = GreaterThan, right = IntExp 4}, thenexp = IntExp 13, elseexp = Just $ StrExp " "})) . happyTokenParse . alexMonadScanTokens)
testParseAppel10 =
    testCase "parses test10 (read from file)" $ (readFile "test/appeltestcases/test10.tig" >>= (assertEqual [] (Program $ WhileExp {wtest = OpExp {left = IntExp 10, oper = GreaterThan, right = IntExp 5}, wbody = OpExp {left = IntExp 5, oper = Add, right = IntExp 6}})) . happyTokenParse . alexMonadScanTokens)
testParseAppel11 =
    testCase "parses test11 (read from file)" $ (readFile "test/appeltestcases/test11.tig" >>= (assertEqual [] (Program $ ForExp { fvar = "i", fescape = True, lo = IntExp 10, hi = StrExp " ", fbody = AssignExp { avar = SimpleVar "i", aexp = OpExp {left = VarExp $ SimpleVar "i", oper = Sub, right = IntExp 1} } })) . happyTokenParse . alexMonadScanTokens)
testParseAppel12 =
    testCase "parses test12 (read from file)" $ (readFile "test/appeltestcases/test12.tig" >>= (assertEqual [] (Program $ LetExp [VarDecl "a" True Nothing (IntExp 0)] (ForExp "i" True (IntExp 0) (IntExp 100) (SeqExp [AssignExp (SimpleVar "a") (OpExp (VarExp $ SimpleVar "a") Add (IntExp 1)), SeqExp []])))) . happyTokenParse . alexMonadScanTokens)
testParseAppel13 =
    testCase "parses test13 (read from file)" $ (readFile "test/appeltestcases/test13.tig" >>= (assertEqual [] (Program $ OpExp {left = IntExp 3, oper = GreaterThan, right = StrExp "df"})) . happyTokenParse . alexMonadScanTokens)
testParseAppel14 =
    testCase "parses test14 (read from file)" $ (readFile "test/appeltestcases/test14.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [TypeDecl {tname = "arrtype", ttyp = ArrayType "int"},TypeDecl {tname = "rectype", ttyp = RecordType [Field {fieldname = "name", escape = True, typ = "string"},Field {fieldname = "id", escape = True, typ = "int"}]},VarDecl {vname = "rec", vescape = True, vtyp = Nothing, vinit = RecordExp {fields = [("id",IntExp 0),("name",StrExp "aname")], rtyp = "rectype"}},VarDecl {vname = "arr", vescape = True, vtyp = Nothing, vinit = ArrayExp {atyp = "arrtype", size = IntExp 3, ainit = IntExp 0}}], lbody = IfExp {iftest = OpExp {left = VarExp (SimpleVar "rec"), oper = NotEqual, right = VarExp (SimpleVar "arr")}, thenexp = IntExp 3, elseexp = Just (IntExp 4)}}))) . happyTokenParse . alexMonadScanTokens)
testLexAppel15 =
    testCase "lexes test15 (read from file)" $ (readFile "test/appeltestcases/test15.tig" >>= (assertEqual [] ([IF, NUM 20, THEN, NUM 3, TEOF])) . alexMonadScanTokens)
testParseAppel15 =
    testCase "parses test15 (read from file)" $ (readFile "test/appeltestcases/test15.tig" >>= (assertEqual [] (Program $ IfExp {iftest = IntExp 20, thenexp = IntExp 3, elseexp = Nothing})) . happyTokenParse . alexMonadScanTokens)
testParseAppel16 =
    testCase "parses test16 (read from file)" $ (readFile "test/appeltestcases/test16.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [TypeDecl {tname = "a", ttyp = NameType "c"},TypeDecl {tname = "b", ttyp = NameType "a"},TypeDecl {tname = "c", ttyp = NameType "d"},TypeDecl {tname = "d", ttyp = NameType "a"}], lbody = StrExp ""}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel17 =
    testCase "parses test17 (read from file)" $ (readFile "test/appeltestcases/test17.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [TypeDecl {tname = "tree", ttyp = RecordType [Field {fieldname = "key", escape = True, typ = "int"},Field {fieldname = "children", escape = True, typ = "treelist"}]},VarDecl {vname = "d", vescape = True, vtyp = Just "int", vinit = IntExp 0},TypeDecl {tname = "treelist", ttyp = RecordType [Field {fieldname = "hd", escape = True, typ = "tree"},Field {fieldname = "tl", escape = True, typ = "treelist"}]}], lbody = VarExp (SimpleVar "d")}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel18 =
    testCase "parses test18 (read from file)" $ (readFile "test/appeltestcases/test18.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [FunDecls [FunDecl {fundeclname = "do_nothing1", params = [Field {fieldname = "a", escape = True, typ = "int"},Field {fieldname = "b", escape = True, typ = "string"}], result = Just "int", body = SeqExp [CallExp {func = "do_nothing2", args = [OpExp {left = VarExp (SimpleVar "a"), oper = Add, right = IntExp 1}]},IntExp 0]}],VarDecl {vname = "d", vescape = True, vtyp = Nothing, vinit = IntExp 0},FunDecls [FunDecl {fundeclname = "do_nothing2", params = [Field {fieldname = "d", escape = True, typ = "int"}], result = Just "string", body = SeqExp [CallExp {func = "do_nothing1", args = [VarExp (SimpleVar "d"),StrExp "str"]},StrExp " "]}]], lbody = CallExp {func = "do_nothing1", args = [IntExp 0,StrExp "str2"]}}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel19 =
    testCase "parses test19 (read from file)" $ (readFile "test/appeltestcases/test19.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [FunDecls [FunDecl {fundeclname = "do_nothing1", params = [Field {fieldname = "a", escape = True, typ = "int"},Field {fieldname = "b", escape = True, typ = "string"}], result = Just "int", body = SeqExp [CallExp {func = "do_nothing2", args = [OpExp {left = VarExp (SimpleVar "a"), oper = Add, right = IntExp 1}]},IntExp 0]},FunDecl {fundeclname = "do_nothing2", params = [Field {fieldname = "d", escape = True, typ = "int"}], result = Just "string", body = SeqExp [CallExp {func = "do_nothing1", args = [VarExp (SimpleVar "a"),StrExp "str"]},StrExp " "]}]], lbody = CallExp {func = "do_nothing1", args = [IntExp 0,StrExp "str2"]}}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel20 =
    testCase "parses test20 (read from file)" $ (readFile "test/appeltestcases/test20.tig" >>= (assertEqual [] (Program $ (WhileExp {wtest = OpExp {left = IntExp 10, oper = GreaterThan, right = IntExp 5}, wbody = SeqExp [OpExp {left = VarExp (SimpleVar "i"), oper = Add, right = IntExp 1},SeqExp []]}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel21 =
    testCase "parses test21 (read from file)" $ (readFile "test/appeltestcases/test21.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [FunDecls [FunDecl {fundeclname = "nfactor", params = [Field {fieldname = "n", escape = True, typ = "int"}], result = Nothing, body = IfExp {iftest = OpExp {left = VarExp (SimpleVar "n"), oper = Equal, right = IntExp 0}, thenexp = IntExp 1, elseexp = Just (OpExp {left = VarExp (SimpleVar "n"), oper = Mul, right = CallExp {func = "nfactor", args = [OpExp {left = VarExp (SimpleVar "n"), oper = Sub, right = IntExp 1}]}})}}]], lbody = CallExp {func = "nfactor", args = [IntExp 10]}}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel22 =
    testCase "parses test22 (read from file)" $ (readFile "test/appeltestcases/test22.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [TypeDecl {tname = "rectype", ttyp = RecordType [Field {fieldname = "name", escape = True, typ = "string"},Field {fieldname = "id", escape = True, typ = "int"}]},VarDecl {vname = "rec1", vescape = True, vtyp = Nothing, vinit = RecordExp {fields = [("id",IntExp 0),("name",StrExp "Name")], rtyp = "rectype"}}], lbody = AssignExp {avar = FieldVar (SimpleVar "rec1") "nam", aexp = StrExp "asd"}}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel23 =
    testCase "parses test23 (read from file)" $ (readFile "test/appeltestcases/test23.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [TypeDecl {tname = "rectype", ttyp = RecordType [Field {fieldname = "name", escape = True, typ = "string"},Field {fieldname = "id", escape = True, typ = "int"}]},VarDecl {vname = "rec1", vescape = True, vtyp = Nothing, vinit = RecordExp {fields = [("id",IntExp 0),("name",StrExp "aname")], rtyp = "rectype"}}], lbody = SeqExp [AssignExp {avar = FieldVar (SimpleVar "rec1") "name", aexp = IntExp 3},AssignExp {avar = FieldVar (SimpleVar "rec1") "id", aexp = StrExp ""}]}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel24 =
    testCase "parses test24 (read from file)" $ (readFile "test/appeltestcases/test24.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [VarDecl {vname = "d", vescape = True, vtyp = Nothing, vinit = IntExp 0}], lbody = VarExp (SubscriptVar (SimpleVar "d") (IntExp 3))}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel25 =
    testCase "parses test25 (read from file)" $ (readFile "test/appeltestcases/test25.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [VarDecl {vname = "d", vescape = True, vtyp = Nothing, vinit = IntExp 0}], lbody = VarExp (FieldVar (SimpleVar "d") "f")}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel26 =
    testCase "parses test26 (read from file)" $ (readFile "test/appeltestcases/test26.tig" >>= (assertEqual [] (Program $ (OpExp {left = IntExp 3, oper = Add, right = StrExp "var"}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel27 =
    testCase "parses test27 (read from file)" $ (readFile "test/appeltestcases/test27.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [VarDecl {vname = "a", vescape = True, vtyp = Nothing, vinit = IntExp 0},FunDecls [FunDecl {fundeclname = "g", params = [Field {fieldname = "a", escape = True, typ = "int"}], result = Just "int", body = VarExp (SimpleVar "a")}]], lbody = CallExp {func = "g", args = [IntExp 2]}}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel28 =
    testCase "parses test28 (read from file)" $ (readFile "test/appeltestcases/test28.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [TypeDecl {tname = "rectype1", ttyp = RecordType [Field {fieldname = "name", escape = True, typ = "string"},Field {fieldname = "id", escape = True, typ = "int"}]},TypeDecl {tname = "rectype2", ttyp = RecordType [Field {fieldname = "name", escape = True, typ = "string"},Field {fieldname = "id", escape = True, typ = "int"}]},VarDecl {vname = "rec1", vescape = True, vtyp = Just "rectype1", vinit = RecordExp {fields = [("id",IntExp 0),("name",StrExp "Name")], rtyp = "rectype2"}}], lbody = VarExp (SimpleVar "rec1")}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel29 =
    testCase "parses test29 (read from file)" $ (readFile "test/appeltestcases/test29.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [TypeDecl {tname = "arrtype1", ttyp = ArrayType "int"},TypeDecl {tname = "arrtype2", ttyp = ArrayType "int"},VarDecl {vname = "arr1", vescape = True, vtyp = Just "arrtype1", vinit = ArrayExp {atyp = "arrtype2", size = IntExp 10, ainit = IntExp 0}}], lbody = VarExp (SimpleVar "arr1")}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel30 =
    testCase "parses test30 (read from file)" $ (readFile "test/appeltestcases/test30.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [TypeDecl {tname = "a", ttyp = ArrayType "int"},TypeDecl {tname = "b", ttyp = NameType "a"},VarDecl {vname = "arr1", vescape = True, vtyp = Just "a", vinit = ArrayExp {atyp = "b", size = IntExp 10, ainit = IntExp 0}}], lbody = VarExp (SubscriptVar (SimpleVar "arr1") (IntExp 2))}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel31 =
    testCase "parses test31 (read from file)" $ (readFile "test/appeltestcases/test31.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [VarDecl {vname = "a", vescape = True, vtyp = Just "int", vinit = StrExp " "}], lbody = VarExp (SimpleVar "a")}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel32 =
    testCase "parses test32 (read from file)" $ (readFile "test/appeltestcases/test32.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [TypeDecl {tname = "arrayty", ttyp = ArrayType "int"},VarDecl {vname = "a", vescape = True, vtyp = Nothing, vinit = ArrayExp {atyp = "arrayty", size = IntExp 10, ainit = StrExp " "}}], lbody = IntExp 0}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel33 =
    testCase "parses test33 (read from file)" $ (readFile "test/appeltestcases/test33.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [VarDecl {vname = "a", vescape = True, vtyp = Nothing, vinit = RecordExp {fields = [], rtyp = "rectype"}}], lbody = IntExp 0}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel34 =
    testCase "parses test34 (read from file)" $ (readFile "test/appeltestcases/test34.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [FunDecls [FunDecl {fundeclname = "g", params = [Field {fieldname = "a", escape = True, typ = "int"},Field {fieldname = "b", escape = True, typ = "string"}], result = Just "int", body = VarExp (SimpleVar "a")}]], lbody = CallExp {func = "g", args = [StrExp "one",StrExp "two"]}}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel35 =
    testCase "parses test35 (read from file)" $ (readFile "test/appeltestcases/test35.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [FunDecls [FunDecl {fundeclname = "g", params = [Field {fieldname = "a", escape = True, typ = "int"},Field {fieldname = "b", escape = True, typ = "string"}], result = Just "int", body = VarExp (SimpleVar "a")}]], lbody = CallExp {func = "g", args = [StrExp "one"]}}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel36 =
    testCase "parses test36 (read from file)" $ (readFile "test/appeltestcases/test36.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [FunDecls [FunDecl {fundeclname = "g", params = [Field {fieldname = "a", escape = True, typ = "int"},Field {fieldname = "b", escape = True, typ = "string"}], result = Just "int", body = VarExp (SimpleVar "a")}]], lbody = CallExp {func = "g", args = [IntExp 3,StrExp "one",IntExp 5]}}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel37 =
    testCase "parses test37 (read from file)" $ (readFile "test/appeltestcases/test37.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [VarDecl {vname = "a", vescape = True, vtyp = Nothing, vinit = IntExp 0},VarDecl {vname = "a", vescape = True, vtyp = Nothing, vinit = StrExp " "}], lbody = IntExp 0}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel38 =
    testCase "parses test38 (read from file)" $ (readFile "test/appeltestcases/test38.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [TypeDecl {tname = "a", ttyp = NameType "int"},TypeDecl {tname = "a", ttyp = NameType "string"}], lbody = IntExp 0}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel39 =
    testCase "parses test39 (read from file)" $ (readFile "test/appeltestcases/test39.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [FunDecls [FunDecl {fundeclname = "g", params = [Field {fieldname = "a", escape = True, typ = "int"}], result = Just "int", body = VarExp (SimpleVar "a")},FunDecl {fundeclname = "g", params = [Field {fieldname = "a", escape = True, typ = "int"}], result = Just "int", body = VarExp (SimpleVar "a")}]], lbody = IntExp 0}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel40 =
    testCase "parses test40 (read from file)" $ (readFile "test/appeltestcases/test40.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [FunDecls [FunDecl {fundeclname = "g", params = [Field {fieldname = "a", escape = True, typ = "int"}], result = Nothing, body = VarExp (SimpleVar "a")}]], lbody = CallExp {func = "g", args = [IntExp 2]}}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel41 =
    testCase "parses test41 (read from file)" $ (readFile "test/appeltestcases/test41.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [TypeDecl {tname = "a", ttyp = NameType "int"}], lbody = LetExp {decls = [TypeDecl {tname = "a", ttyp = NameType "string"}], lbody = IntExp 0}}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel42 =
    testCase "parses test42 (read from file)" $ (readFile "test/appeltestcases/test42.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [TypeDecl {tname = "arrtype1", ttyp = ArrayType "int"},TypeDecl {tname = "rectype1", ttyp = RecordType [Field {fieldname = "name", escape = True, typ = "string"},Field {fieldname = "address", escape = True, typ = "string"},Field {fieldname = "id", escape = True, typ = "int"},Field {fieldname = "age", escape = True, typ = "int"}]},TypeDecl {tname = "arrtype2", ttyp = ArrayType "rectype1"},TypeDecl {tname = "rectype2", ttyp = RecordType [Field {fieldname = "name", escape = True, typ = "string"},Field {fieldname = "dates", escape = True, typ = "arrtype1"}]},TypeDecl {tname = "arrtype3", ttyp = ArrayType "string"},VarDecl {vname = "arr1", vescape = True, vtyp = Nothing, vinit = ArrayExp {atyp = "arrtype1", size = IntExp 10, ainit = IntExp 0}},VarDecl {vname = "arr2", vescape = True, vtyp = Nothing, vinit = ArrayExp {atyp = "arrtype2", size = IntExp 5, ainit = RecordExp {fields = [("age",IntExp 0),("id",IntExp 0),("address",StrExp "somewhere"),("name",StrExp "aname")], rtyp = "rectype1"}}},VarDecl {vname = "arr3", vescape = True, vtyp = Just "arrtype3", vinit = ArrayExp {atyp = "arrtype3", size = IntExp 100, ainit = StrExp ""}},VarDecl {vname = "rec1", vescape = True, vtyp = Nothing, vinit = RecordExp {fields = [("age",IntExp 44),("id",IntExp 2432),("address",StrExp "Kapou"),("name",StrExp "Kapoios")], rtyp = "rectype1"}},VarDecl {vname = "rec2", vescape = True, vtyp = Nothing, vinit = RecordExp {fields = [("dates",ArrayExp {atyp = "arrtype1", size = IntExp 3, ainit = IntExp 1900}),("name",StrExp "Allos")], rtyp = "rectype2"}}], lbody = SeqExp [AssignExp {avar = SubscriptVar (SimpleVar "arr1") (IntExp 0), aexp = IntExp 1},AssignExp {avar = SubscriptVar (SimpleVar "arr1") (IntExp 9), aexp = IntExp 3},AssignExp {avar = FieldVar (SubscriptVar (SimpleVar "arr2") (IntExp 3)) "name", aexp = StrExp "kati"},AssignExp {avar = FieldVar (SubscriptVar (SimpleVar "arr2") (IntExp 1)) "age", aexp = IntExp 23},AssignExp {avar = SubscriptVar (SimpleVar "arr3") (IntExp 34), aexp = StrExp "sfd"},AssignExp {avar = FieldVar (SimpleVar "rec1") "name", aexp = StrExp "sdf"},AssignExp {avar = SubscriptVar (FieldVar (SimpleVar "rec2") "dates") (IntExp 0), aexp = IntExp 2323},AssignExp {avar = SubscriptVar (FieldVar (SimpleVar "rec2") "dates") (IntExp 2), aexp = IntExp 2323}]}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel43 =
    testCase "parses test43 (read from file)" $ (readFile "test/appeltestcases/test43.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [VarDecl {vname = "a", vescape = True, vtyp = Nothing, vinit = SeqExp []}], lbody = OpExp {left = VarExp (SimpleVar "a"), oper = Add, right = IntExp 3}}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel44 =
    testCase "parses test44 (read from file)" $ (readFile "test/appeltestcases/test44.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [TypeDecl {tname = "rectype", ttyp = RecordType [Field {fieldname = "name", escape = True, typ = "string"},Field {fieldname = "id", escape = True, typ = "int"}]},VarDecl {vname = "b", vescape = True, vtyp = Just "rectype", vinit = NilExp}], lbody = AssignExp {avar = SimpleVar "b", aexp = NilExp}}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel45 =
    testCase "parses test45 (read from file)" $ (readFile "test/appeltestcases/test45.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [TypeDecl {tname = "rectype", ttyp = RecordType [Field {fieldname = "name", escape = True, typ = "string"},Field {fieldname = "id", escape = True, typ = "int"}]},VarDecl {vname = "a", vescape = True, vtyp = Nothing, vinit = NilExp}], lbody = VarExp (SimpleVar "a")}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel46 =
    testCase "parses test46 (read from file)" $ (readFile "test/appeltestcases/test46.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [TypeDecl {tname = "rectype", ttyp = RecordType [Field {fieldname = "name", escape = True, typ = "string"},Field {fieldname = "id", escape = True, typ = "int"}]},VarDecl {vname = "b", vescape = True, vtyp = Just "rectype", vinit = NilExp}], lbody = SeqExp [OpExp {left = VarExp (SimpleVar "b"), oper = Equal, right = NilExp},OpExp {left = VarExp (SimpleVar "b"), oper = NotEqual, right = NilExp}]}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel47 =
    testCase "parses test47 (read from file)" $ (readFile "test/appeltestcases/test47.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [TypeDecl {tname = "a", ttyp = NameType "int"},VarDecl {vname = "b", vescape = True, vtyp = Nothing, vinit = IntExp 4},TypeDecl {tname = "a", ttyp = NameType "string"}], lbody = IntExp 0}))) . happyTokenParse . alexMonadScanTokens)
testParseAppel48 =
    testCase "parses test48 (read from file)" $ (readFile "test/appeltestcases/test48.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [FunDecls [FunDecl {fundeclname = "g", params = [Field {fieldname = "a", escape = True, typ = "int"}], result = Just "int", body = VarExp (SimpleVar "a")}],TypeDecl {tname = "t", ttyp = NameType "int"},FunDecls [FunDecl {fundeclname = "g", params = [Field {fieldname = "a", escape = True, typ = "int"}], result = Just "int", body = VarExp (SimpleVar "a")}]], lbody = IntExp 0}))) . happyTokenParse . alexMonadScanTokens)
testLexAppel49 =
    testCase "lexes test49 (read from file)" $ (readFile "test/appeltestcases/test49.tig" >>= (assertEqual [] ([LET, TYPE, ID "rectype", EQUAL, LBRACE, ID "name", COLON, ID "string", COMMA, ID "id", COLON, ID "int", RBRACE, VAR, ID "a", DEFINE, ID "rectype", NIL, IN, ID "a", END, TEOF])) . alexMonadScanTokens)
-- NOTE: turn this test back on once parser is updated to provide error handling
--testParseAppel49 =
    --testCase "parses test49 (read from file)" $ (readFile "test/appeltestcases/test49.tig" >>= (assertEqual [] (Program $ NilExp)) . happyTokenParse . alexMonadScanTokens)
testParseAppelMerge =
    testCase "parses merge.tig (read from file)" $ (readFile "test/appeltestcases/merge.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [TypeDecl {tname = "any", ttyp = RecordType [Field {fieldname = "any", escape = True, typ = "int"}]},VarDecl {vname = "buffer", vescape = True, vtyp = Nothing, vinit = CallExp {func = "getchar", args = []}},FunDecls [FunDecl {fundeclname = "readint", params = [Field {fieldname = "any", escape = True, typ = "any"}], result = Just "int", body = LetExp {decls = [VarDecl {vname = "i", vescape = True, vtyp = Nothing, vinit = IntExp 0},FunDecls [FunDecl {fundeclname = "isdigit", params = [Field {fieldname = "s", escape = True, typ = "string"}], result = Just "int", body = IfExp {iftest = OpExp {left = CallExp {func = "ord", args = [VarExp (SimpleVar "buffer")]}, oper = GreaterEqual, right = CallExp {func = "ord", args = [StrExp "0"]}}, thenexp = OpExp {left = CallExp {func = "ord", args = [VarExp (SimpleVar "buffer")]}, oper = LessEqual, right = CallExp {func = "ord", args = [StrExp "9"]}}, elseexp = Just (IntExp 0)}},FunDecl {fundeclname = "skipto", params = [], result = Nothing, body = WhileExp {wtest = IfExp {iftest = OpExp {left = VarExp (SimpleVar "buffer"), oper = Equal, right = StrExp " "}, thenexp = IntExp 1, elseexp = Just (OpExp {left = VarExp (SimpleVar "buffer"), oper = Equal, right = StrExp "\n"})}, wbody = AssignExp {avar = SimpleVar "buffer", aexp = CallExp {func = "getchar", args = []}}}}]], lbody = SeqExp [CallExp {func = "skipto", args = []},AssignExp {avar = FieldVar (SimpleVar "any") "any", aexp = CallExp {func = "isdigit", args = [VarExp (SimpleVar "buffer")]}},WhileExp {wtest = CallExp {func = "isdigit", args = [VarExp (SimpleVar "buffer")]}, wbody = SeqExp [AssignExp {avar = SimpleVar "i", aexp = OpExp {left = OpExp {left = OpExp {left = VarExp (SimpleVar "i"), oper = Mul, right = IntExp 10}, oper = Add, right = CallExp {func = "ord", args = [VarExp (SimpleVar "buffer")]}}, oper = Sub, right = CallExp {func = "ord", args = [StrExp "0"]}}},AssignExp {avar = SimpleVar "buffer", aexp = CallExp {func = "getchar", args = []}}]},VarExp (SimpleVar "i")]}}],TypeDecl {tname = "list", ttyp = RecordType [Field {fieldname = "first", escape = True, typ = "int"},Field {fieldname = "rest", escape = True, typ = "list"}]},FunDecls [FunDecl {fundeclname = "readlist", params = [], result = Just "list", body = LetExp {decls = [VarDecl {vname = "any", vescape = True, vtyp = Nothing, vinit = RecordExp {fields = [("any",IntExp 0)], rtyp = "any"}},VarDecl {vname = "i", vescape = True, vtyp = Nothing, vinit = CallExp {func = "readint", args = [VarExp (SimpleVar "any")]}}], lbody = IfExp {iftest = VarExp (FieldVar (SimpleVar "any") "any"), thenexp = RecordExp {fields = [("rest",CallExp {func = "readlist", args = []}),("first",VarExp (SimpleVar "i"))], rtyp = "list"}, elseexp = Just NilExp}}},FunDecl {fundeclname = "merge", params = [Field {fieldname = "a", escape = True, typ = "list"},Field {fieldname = "b", escape = True, typ = "list"}], result = Just "list", body = IfExp {iftest = OpExp {left = VarExp (SimpleVar "a"), oper = Equal, right = NilExp}, thenexp = VarExp (SimpleVar "b"), elseexp = Just (IfExp {iftest = OpExp {left = VarExp (SimpleVar "b"), oper = Equal, right = NilExp}, thenexp = VarExp (SimpleVar "a"), elseexp = Just (IfExp {iftest = OpExp {left = VarExp (FieldVar (SimpleVar "a") "first"), oper = LessThan, right = VarExp (FieldVar (SimpleVar "b") "first")}, thenexp = RecordExp {fields = [("rest",CallExp {func = "merge", args = [VarExp (FieldVar (SimpleVar "a") "rest"),VarExp (SimpleVar "b")]}),("first",VarExp (FieldVar (SimpleVar "a") "first"))], rtyp = "list"}, elseexp = Just (RecordExp {fields = [("rest",CallExp {func = "merge", args = [VarExp (SimpleVar "a"),VarExp (FieldVar (SimpleVar "b") "rest")]}),("first",VarExp (FieldVar (SimpleVar "b") "first"))], rtyp = "list"})})})}},FunDecl {fundeclname = "printint", params = [Field {fieldname = "i", escape = True, typ = "int"}], result = Nothing, body = LetExp {decls = [FunDecls [FunDecl {fundeclname = "f", params = [Field {fieldname = "i", escape = True, typ = "int"}], result = Nothing, body = IfExp {iftest = OpExp {left = VarExp (SimpleVar "i"), oper = GreaterThan, right = IntExp 0}, thenexp = SeqExp [CallExp {func = "f", args = [OpExp {left = VarExp (SimpleVar "i"), oper = Div, right = IntExp 10}]},CallExp {func = "print", args = [CallExp {func = "chr", args = [OpExp {left = OpExp {left = VarExp (SimpleVar "i"), oper = Sub, right = OpExp {left = OpExp {left = VarExp (SimpleVar "i"), oper = Div, right = IntExp 10}, oper = Mul, right = IntExp 10}}, oper = Add, right = CallExp {func = "ord", args = [StrExp "0"]}}]}]}], elseexp = Nothing}}]], lbody = IfExp {iftest = OpExp {left = VarExp (SimpleVar "i"), oper = LessThan, right = IntExp 0}, thenexp = SeqExp [CallExp {func = "print", args = [StrExp "-"]},CallExp {func = "f", args = [OpExp {left = IntExp 0, oper = Sub, right = VarExp (SimpleVar "i")}]}], elseexp = Just (IfExp {iftest = OpExp {left = VarExp (SimpleVar "i"), oper = GreaterThan, right = IntExp 0}, thenexp = CallExp {func = "f", args = [VarExp (SimpleVar "i")]}, elseexp = Just (CallExp {func = "print", args = [StrExp "0"]})})}}},FunDecl {fundeclname = "printlist", params = [Field {fieldname = "l", escape = True, typ = "list"}], result = Nothing, body = IfExp {iftest = OpExp {left = VarExp (SimpleVar "l"), oper = Equal, right = NilExp}, thenexp = CallExp {func = "print", args = [StrExp "\n"]}, elseexp = Just (SeqExp [CallExp {func = "printint", args = [VarExp (FieldVar (SimpleVar "l") "first")]},CallExp {func = "print", args = [StrExp " "]},CallExp {func = "printlist", args = [VarExp (FieldVar (SimpleVar "l") "rest")]}])}}],VarDecl {vname = "list1", vescape = True, vtyp = Nothing, vinit = CallExp {func = "readlist", args = []}},VarDecl {vname = "list2", vescape = True, vtyp = Nothing, vinit = SeqExp [AssignExp {avar = SimpleVar "buffer", aexp = CallExp {func = "getchar", args = []}},CallExp {func = "readlist", args = []}]}], lbody = CallExp {func = "printlist", args = [CallExp {func = "merge", args = [VarExp (SimpleVar "list1"),VarExp (SimpleVar "list2")]}]}}))) . happyTokenParse . alexMonadScanTokens)
testParseAppelQueens =
    testCase "parses queens.tig (read from file)" $ (readFile "test/appeltestcases/queens.tig" >>= (assertEqual [] (Program $ (LetExp {decls = [VarDecl {vname = "N", vescape = True, vtyp = Nothing, vinit = IntExp 8},TypeDecl {tname = "intArray", ttyp = ArrayType "int"},VarDecl {vname = "row", vescape = True, vtyp = Nothing, vinit = ArrayExp {atyp = "intArray", size = VarExp (SimpleVar "N"), ainit = IntExp 0}},VarDecl {vname = "col", vescape = True, vtyp = Nothing, vinit = ArrayExp {atyp = "intArray", size = VarExp (SimpleVar "N"), ainit = IntExp 0}},VarDecl {vname = "diag1", vescape = True, vtyp = Nothing, vinit = ArrayExp {atyp = "intArray", size = OpExp {left = OpExp {left = VarExp (SimpleVar "N"), oper = Add, right = VarExp (SimpleVar "N")}, oper = Sub, right = IntExp 1}, ainit = IntExp 0}},VarDecl {vname = "diag2", vescape = True, vtyp = Nothing, vinit = ArrayExp {atyp = "intArray", size = OpExp {left = OpExp {left = VarExp (SimpleVar "N"), oper = Add, right = VarExp (SimpleVar "N")}, oper = Sub, right = IntExp 1}, ainit = IntExp 0}},FunDecls [FunDecl {fundeclname = "printboard", params = [], result = Nothing, body = SeqExp [ForExp {fvar = "i", fescape = True, lo = IntExp 0, hi = OpExp {left = VarExp (SimpleVar "N"), oper = Sub, right = IntExp 1}, fbody = SeqExp [ForExp {fvar = "j", fescape = True, lo = IntExp 0, hi = OpExp {left = VarExp (SimpleVar "N"), oper = Sub, right = IntExp 1}, fbody = CallExp {func = "print", args = [IfExp {iftest = OpExp {left = VarExp (SubscriptVar (SimpleVar "col") (VarExp (SimpleVar "i"))), oper = Equal, right = VarExp (SimpleVar "j")}, thenexp = StrExp " O", elseexp = Just (StrExp " .")}]}},CallExp {func = "print", args = [StrExp "\n"]}]},CallExp {func = "print", args = [StrExp "\n"]}]},FunDecl {fundeclname = "try", params = [Field {fieldname = "c", escape = True, typ = "int"}], result = Nothing, body = IfExp {iftest = OpExp {left = VarExp (SimpleVar "c"), oper = Equal, right = VarExp (SimpleVar "N")}, thenexp = CallExp {func = "printboard", args = []}, elseexp = Just (ForExp {fvar = "r", fescape = True, lo = IntExp 0, hi = OpExp {left = VarExp (SimpleVar "N"), oper = Sub, right = IntExp 1}, fbody = IfExp {iftest = IfExp {iftest = IfExp {iftest = OpExp {left = VarExp (SubscriptVar (SimpleVar "row") (VarExp (SimpleVar "r"))), oper = Equal, right = IntExp 0}, thenexp = OpExp {left = VarExp (SubscriptVar (SimpleVar "diag1") (OpExp {left = VarExp (SimpleVar "r"), oper = Add, right = VarExp (SimpleVar "c")})), oper = Equal, right = IntExp 0}, elseexp = Just (IntExp 0)}, thenexp = OpExp {left = VarExp (SubscriptVar (SimpleVar "diag2") (OpExp {left = OpExp {left = VarExp (SimpleVar "r"), oper = Add, right = IntExp 7}, oper = Sub, right = VarExp (SimpleVar "c")})), oper = Equal, right = IntExp 0}, elseexp = Just (IntExp 0)}, thenexp = SeqExp [AssignExp {avar = SubscriptVar (SimpleVar "row") (VarExp (SimpleVar "r")), aexp = IntExp 1},AssignExp {avar = SubscriptVar (SimpleVar "diag1") (OpExp {left = VarExp (SimpleVar "r"), oper = Add, right = VarExp (SimpleVar "c")}), aexp = IntExp 1},AssignExp {avar = SubscriptVar (SimpleVar "diag2") (OpExp {left = OpExp {left = VarExp (SimpleVar "r"), oper = Add, right = IntExp 7}, oper = Sub, right = VarExp (SimpleVar "c")}), aexp = IntExp 1},AssignExp {avar = SubscriptVar (SimpleVar "col") (VarExp (SimpleVar "c")), aexp = VarExp (SimpleVar "r")},CallExp {func = "try", args = [OpExp {left = VarExp (SimpleVar "c"), oper = Add, right = IntExp 1}]},AssignExp {avar = SubscriptVar (SimpleVar "row") (VarExp (SimpleVar "r")), aexp = IntExp 0},AssignExp {avar = SubscriptVar (SimpleVar "diag1") (OpExp {left = VarExp (SimpleVar "r"), oper = Add, right = VarExp (SimpleVar "c")}), aexp = IntExp 0},AssignExp {avar = SubscriptVar (SimpleVar "diag2") (OpExp {left = OpExp {left = VarExp (SimpleVar "r"), oper = Add, right = IntExp 7}, oper = Sub, right = VarExp (SimpleVar "c")}), aexp = IntExp 0}], elseexp = Nothing}})}}]], lbody = CallExp {func = "try", args = [IntExp 0]}}))) . happyTokenParse . alexMonadScanTokens)
    
-- testParseAppel6 =
    --testCase "parses test6 (read from file)" $ (readFile "test/appeltestcases/test6.tig" >>= (assertEqual [] (Program $ NilExp)) . happyTokenParse . alexMonadScanTokens)
    
